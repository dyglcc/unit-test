一 闲话单元测试
我们经常讲“前人种树，后人乘凉”，然而在软件开发中，往往呈现出来的却是截然相反的景象，我们在绩效和指标的驱使下，主动或被动的留下来大量坏味道的代码，在短时间内顺利的完成项目，此后却花了数倍于开发的时间来维护此项目，可谓“前人砍树，后人遭殃”，讽刺的是，砍树的人往往因为优秀的绩效，此时已经步步高升，而遭殃的往往是意气风发，步入职场的年轻人，如此不断轮回。所以，为了打破轮回，从一点一滴做起吧，“树”的种类众多，作为任意一名普通的软件工程师，种好单元测试这棵树，便是撒下一片荫凉。

关于单元测试，很多人心中会有以下几个疑问：
(1)为什么要写？
(2)这不是QA人员该做的吗？
(3)需求天天变，功能都来不及完成了，还要同时维护代码和UT，四不四傻啊？
(4)我要怎么写UT（特别是Android单元测试）？

关于第一个问题，首先我们反问自己几个问题：

(1)我们在学习任何一个技术框架，比如 retofit2 、 Dagger2 时，是不是第一时间先打开官方文档（或者任意文档），然后查阅api如何调用的代码，而官方文档往往都会在最醒目的地方，用最简洁的代码向我们说明了api如何使用?

其实，当我们在写单元测试时，为了测试某个功能或某个api，首先得调用相关的代码，因此我们留下来的便是一段如何调用的代码。这些代码的价值在于为以后接手维护/重构/优化功能的人，留下一份程序猿最愿意去阅读的文档。

(2)当你写单元测试的时候，是不是发现很多代码无法测试？撇开对UT测试框架不熟悉的因素之外，是不是因为你的代码里一个方法做了太多事情，或者代码的封装性不够好，或者一个方法需要有其他很多依赖才能测试（高耦合），而此时，为了让你的代码可测试，你是不是会主动去优化一下代码？

(3)是不是对重构没信心？这个话题太老生常谈了，配备有价值的、高覆盖率的单元测试可解决此问题。

(4)当你在写Android代码（比如网络请求和DB操作）的时候，是如何测试的？跑起来整个App，点了好几步操作后，终于到达要测试的功能，然后巨慢无比的Debug？如果你写UT，并使用Robolectric这样的框架，你不仅可以脱离Android环境对代码进行调试，还可以很快速的定位和Debug你想要调试的代码，大大的提升了开发效率。

以上，便是写好单元测试的意义。

关于第二个问题，己所不欲勿施于人
我始终觉得让QA写UT，是一种傻叉的行为。单元测试是一种白盒测试，本来就是开发分内之事，难道让QA去阅读你恶心的充满坏味道的代码，然后硬着头皮写出UT？试想一下，你的产品经理让你画原型写需求文档，你的领导让你去市场部辅助吹嘘产品，促进销售，你会不会有种吃了翔味巧克力的感觉？所以，己所不欲勿施于人。

这个问题有点头疼，总之，尽量提高我们的代码设计和写UT的速度，以便应对各种不合理的需求和项目。

前面三个问题，或多或少是心态的问题，调整好心态，认可UT的优点，尝试走第一步看看。而第四个问题，如何写？则是笔者这系列文章的核心内容，在我的第一篇《Robolectric3.0(一)》中已经介绍了这个框架的特点，环境搭建，三大组件（Activity、Bordercast、Service）的测试，以及Shadow的使用，这篇文章，主要介绍网络请求和数据库相关的功能如何测试。

二 日志输出
Robolectric对日志输出的支持其实非常简单，为什么把它单独列一个条目来讲解？因为往往我们在写UT的过程，其实也是在调试代码，而日志输出对于代码调试起到极大的作用。我们只需要在每个TestCase的setUp()里执行ShadowLog.stream = System.out即可，如：

@Before
public void setUp() throws URISyntaxException {
    //输出日志
    ShadowLog.stream = System.out;
}
此时，无论是功能代码还是测试代码中的 Log.i()之类的相关日志都将输出在控制面板中，调试起功能来，简直爽得不要不要的。




写UT是一种非常好的编程习惯，但是UT虽好，切忌贪杯，作为一名技术领导者，切忌拿测试覆盖率作为指标，如此一来会滋生开发者的抵触心理，导致乱写一通。作为开发者，应该时刻思考什么才是有价值的UT，什么逻辑没必要写(比如set和get)，这样才不会疲于奔命且觉得乏味。其实很多事情都是因果关系，开发人员不写，所以leader强制写，而leader强制写，开发人员会抵触而乱写。所以，让各自做好，一起来享受UT带来的高质量的代码以及为了可测试而去思考代码设计的编程乐趣。

单元测试和集成测试区别




之后学习AndroidJUnitRunner，Google官方的android单元测试框架之一，使用跟Junit是一样的，只不过需要运行在android真机或模拟器环境。由于mockito只在jvm环境生效，而android是运行在Dalvik或ART，所以AndroidJUnitRunner不能使用mockito。



https://www.jianshu.com/p/bc99678b1d6e


https://www.jianshu.com/p/fa41fb80d2b8

https://www.jianshu.com/p/fa41fb80d2b8

